import discord
import os
import random
import time
import asyncio
from discord.utils import get
from discord.ext import commands
from random import randint
bot_Mess = commands.Bot(command_prefix=('+')) #префикс всех команд у бота устанавливается +
bot_Mess.remove_command('help') #удаление команды help

@bot_Mess.command(pass_context = True)
async def clear(ctx, amount=25): #создает функцию очистки последних сообщений в канале
   '''Функция запускается при отправке участником discord-сервера сообщения +clear amount, где amount - количество сообщений. она служит для очистки последних сообщений количества amoun.
   аргумент ctx функции отвечает за контекст
   аргумент amount функции отвечает за количество находящихся в чате сообщений, которые необходимо удалить'''
   await ctx.channel.purge(limit=amount + 1) #в этой строчке происходит очистка канала, в который была отправлена команда об очистке на amount сообщений. если не устанавливать amount при написании команды, бот удалит последние 25 отправленных сообщений. +1 потому что само сообщение с командой для очистки также учитывается при подсчете, из-за этого из уже находившихся в чате сообщений удаляется на одно меньше

@bot_Mess.command(pass_context = True)
async def BW(ctx): #создает функцию, отправляющую запрещенные на сервере слова
   '''Функция запускается при отправке участником discord-сервера сообщения +BW. она служит для получения ранее установленного на сервере списка запрещенных для использования слов. список таких слов, то выведет, что эти слова не установлены.
   badwords - переменная, содержащая массив слов из файла, куда записываются запретные слова
   read_words - переменная, куда считывается файл с запретными словами
   аргумент ctx функции отвечает за контекст'''
   badwords = [] #задается переменная badwords, описанная выше
   try: #программа пытается открыть файл words.txt на чтение. если такого файла не находится, то выполняется except
      read_words = open('words.txt', 'r') #открывает файл words.txt, который лежит в той же папке, что и бот
   except FileNotFoundError: #выполняется, если при try возникает ошибка. тогда сначала файл создается и открывается на запись, затем закрывается и, наконец, открывается на чтение
      read_words = open('words.txt', 'w') #создает файл words.txt, открывает его на запись
      read_words.close() #закрывает файл words.txt
      read_words = open('words.txt', 'r') #открывает файл words.txt на чтение
   for word in read_words: #считывает строки в ранее открытом файле words.txt(в функции addBW каждое новое запретное на сервере слово добавляется в файл words.txt с новой строки
      badwords.append(word.strip()) #записывает считываемые строкой кода ранее строки файла words.txt в массив badwords как новые элементы
   read_words.close() #закрывает файл words.txt
   if badwords != []: #следующая строка выполняется, если в badwords есть какие-либо строки(если список запрещенных на сервере слов не пустой
      await ctx.send(f"Current forbidden words list: {badwords}") #при ранее описанном условии выводит все запрещенные на сервере слова
   else: #выполняется, если на сервере нет недопустимых слов
      await ctx.send("No forbidden words added on this server. Feel free to write whatever you want!") #если на сервере нет запрещенных слов, то пишет в чат, что их нет

@bot_Mess.command(pass_context = True)
async def bot_commands(ctx): #создает функцию, отправляющую список всех команд бота
   '''Функция запускается при отправке участником сервера сообщения +bot_commands. она служит для служит для получения в чат списка применимых к боту команд
   channel - канал сервера, в который отдаются команды'''
   channel = bot_Mess.get_channel(920228968907554858) #задание того канала, в который будет писать бот
   await channel.send('This is what i can do:\n'+
         '+bot_commands: you can check all commands\n'+
         '+BW: you can check all forbidden words\n'+
         '+addBW: you can add one or more words to forbidden words list. To do this, write them after a command\n'+
         '+clearBW: you can clear forbidden words list\n'+
         '+createCh: you can create one or more text channel(s). To do this, write their names after a command\n'+
         '+deleteCh: you can delete one or more text channel(s). To do this, write their names after a command\n'+
         '+clear: you can delete some last messages. To do this, write count after a command. Default value: 25\n'+
         '+kick: you can kick a user who breaks the rules. To do this, mention him after a command\n'+
         '+choose: bot helps you to choose on of the written variants\n'+
         '+roll: returns random number from 1 to 100\n'+
         '+del_role: deletes a role from the list\n'+
         '+create_role: creates your personally role\n'+
         '+give_role: gives you one of the created roles list\n'+
         '+remove_role: removes a role on the list\n'+
         '+mute: mutes a mentioned member\n'+
         '+rusgame: play a russian game!\n'+
         '+rps: play rock paper scissors\n'+
         '+guess_game: play a number guessing game') #вывод всего списка команд бота, каждая команда с новой строчки

@bot_Mess.command(pass_context = True)
async def addBW(ctx): #создает функцию, пополняющую файл с запрещенными на сервере словами
   '''Функция запускается при отправке участником сервера сообщения +addBW она служит для добавления через пробел слов, которые требуется добавить в список запретных
   new_badwords - переменная, записывающая в массив записанные через пробел слова, которые требуется запретить на сервере
   channel - канал сервера, в который бот будет писать
   banwords_list - переменная, куда считывается на запись файл с запретными словами
   аргумент ctx функции отвечает за контекст'''
   new_badwords = ctx.message.content.split(' ') #создается список новых запрещенных слов. в него также будет записана сама команда для вызова функции(+addBW), но учавствовать в программе дальше и записываться в список уже имеющихся слов тоже не будет
   if new_badwords == ['+addBW']: #выполняется, если с командой на вход не поступило никаких параметров(новых слов)
      channel = bot_Mess.get_channel(920228968907554858) #задание того канала, в который будет писать бот
      await channel.send('To add some new words, write them separated by space') #отправка сообщения, говорящего о том, как правильно использовать команду: писать команду, после нее слова, которые нужно запретить
   else: #выполняется, если пользователь все ввел верно и на вход с командой поступили нужные слова
      try: #пробует выполнить открытие файла на дозапись в конец файла с запрещенными словами
         banwords_list = open('words.txt', 'a') #само открытие файла
      except FileNotFoundError: #если файла в папке с ботом не находится, то сначала файл создается и открывается на запись, затем закрывается и, наконец, открывается на дозапись
         banwords_list = open('words.txt', 'w') #создает файл words.txt, открывает его на запись
         banwords_list.close() #закрывает файл words.txt
         banwords_list = open('words.txt', 'a') #открывает файл words.txt на чтение
      if os.stat("words.txt").st_size > 0: #проверяет файл на пустоту. если в файле уже есть слова, то в следующие две строчки он добавляет новые, полученные ранее через знак \n переноса строки
         for word in new_badwords[1:]:#проходится по новым запретным словам
            if not word in '+clearBW': #проверяет слово на то, что оно не входит в команду на очистку списка запрещенных слов
                banwords_list.write('\n' + word) #добавляет их с новой строки в файл
      else: #выполняется, если файл с запретными словами пустой, что выполняется, если он был либо только что создан, либо очищен при помощи команды +clearBW
         banwords_list.write(new_badwords[1]) #записвает без переноса на новую строку первое слово из введенных пользователем вместе с командой. если бы ну было проверки на пустоту файла, и все состояло только из строчек кода под else:, то на этом моменте для пустого файла перенос был бы уже на первой строке, что создавало бы ситуацию, что введенные слова записываются начиная со 2-й строки, а 1-ая остается пустой, и из-за этого любое сообщение из отправленных пользователями, удалялось бы с жалобой на то, что содержит запрещенное на сервере слово(следует из того, что пустая строка является подстрокой любой другой строки)
         if len(new_badwords) > 2: #проверяет, что количество введенных пользователем слов, которые надо запретить, больше одного(элемент массива new_badwords с индексом 0 - команда +addBW, которую, очевидно, в запретные слова вносить не нужно
            for word in new_badwords[2:]: #дописывает в конец открытого файла все  оставшиеся незаписанными слова
                if not word in '+clearBW': #проверяет слово на то, что оно не входит в команду на очистку списка запрещенных слов
                    banwords_list.write('\n' + word) #собственно, сама команда для дозаписи
      channel = bot_Mess.get_channel(920228968907554858) #задание того канала, в который будет писать бот
      await channel.send('New words were successfully added to list') #отправляет отчет об успешной записи слов в файл

@bot_Mess.command(pass_context = True)
async def clearBW(ctx): #создает функцию, очищающую файл с запрещенными словами
   '''Функция очищает файл от всех добавленных туда запретных слов
   badwords - переменная, куда считывается полностью очищенный в силу аргумента "w" у функции open() файл с запрещенными словами
   channel - канал сервера, в который бот будет писать
   аргумент ctx функции отвечает за контекст'''
   badwords = open('words.txt', "w") #открытие очещенного от запрещенных слов файла на запись
   badwords.close() #закрытие файла
   channel = bot_Mess.get_channel(920228968907554858) #задание того канала, в который будет писать бот
   await channel.send('Forbidden words list was successfully erased') #отправляет отчет об успешной очистке файла

@bot_Mess.event
async def on_message(message): #создает функцию, проверяющую каждое отправленное сообщение на допустимость
   '''Функция, активирующаяся при отправлении пользователем любого сообщения. Проверяет его на наличие ссылок(для защиты других пользователей) и на наличие запрещенных на сервере слов
   аргумент message функии - полученное сообщение
   channel - канал сервера, в который бот будет писать
   word - переменная, получающая и хранящая текст сообщения
   embed - переменная, хранящая особый формат, в котором должно выводться сообщение о нарушении
   badwords_file - переменная, в которую открывается для чтения файл с запрещенными словами
   badwords - переменная, хранящая запретные слова'''
   if message.author.name != 'Mimist': #проверяет, что имя пользователя, отравившего сообщение - не имя самого бота. сделано, чтобы бот не зациклился
      #следующая часть кода была частично скопирована со следующей статьи: https://dev.to/mikeywastaken/get-started-with-discord-py-3c51
      if 'https://' in message.content or 'http://' in message.content: #проверяет сообщение на наличие ссылок
         await message.delete() #если в сообщении содержится ссылка, то удаляет ее
         await message.channel.send(f"{message.author.mention} Don't send links!") #отправляет в канал, в котором считал сообщение, требование к пользователю не отправлять ссылки
         channel = bot_Mess.get_channel(920228968907554858) #задание того канала, в который будет писать бот
         word = message.content #задание содержимого сообщения в отдельную переменную
         embed = discord.Embed(title="Suspicious link alert!", description=f"{message.author.name} just sent a suspicious link: {word}",color=discord.Color.blurple()) #задает особый формат, в котором должно выводться сообщение о нарушении
         await channel.send(embed=embed) #отправляет сообщение в указанный выше канал в особом, также указанном выше, формате
         await message.author.send(f"Sending links isn't available on this server") #отправляет личное сообщение пользователю с информацией о том, что ссылки на сервере отправлять нельзя
         return #завершает работу функции
      else: #выполняется если не найдено ссылки в сообщении
         try: #пробует открыть на чтение файл с запрещенными словами
            badwords_file = open('words.txt', 'r') #открытие файла с запретными словами
         except FileNotFoundError: #если файла в папке с ботом не находится, то сначала файл создается и открывается на запись, затем закрывается и, наконец, открывается на чтение
            badwords_file = open('words.txt', 'w') #создание файла и открытие его на запись
            badwords_file.close() #закрытие файла
            badwords_file = open('words.txt', 'r') #открытие файла на чтение
         badwords = [] #создает переменную, в которую перенесутся запрещенные слова
         for word in badwords_file: #записывает все строки файла с запрещенными на сервере словами в массив как отдельные элементы(одна строка в файле содержит одно запрещенное слово)
            badwords.append(word.strip()) #записывает считываемые строкой кода ранее строки файла words.txt в массив badwords как новые элементы
         badwords_file.close() #закрывает открыты на чтение файл с запрещенными словами
         message_words = message.content.split(' ') #создает массив со словами из полученного сообщения
         for word in badwords: #перебирает запрещенные слова
            if word in message_words: #проверяет считанное сообщение на наличие в нем запрщенного на сервере слова
               await message.delete() #удаляет сообщение, если находит в нем запрещенное слово
               await message.channel.send(f"{message.author.mention} Don't use that word!") #отправляет в чат требование к пользователю не использовать запрещенные слова
               channel = bot_Mess.get_channel(920228968907554858) #задание того канала, в который будет писать бот следующие сообщения
               word = message.content #задание содержимого сообщения в отдельную переменную
               embed = discord.Embed(title="Profanity Alert!", description=f"{message.author.name} just said ||{word}||", color=discord.Color.blurple()) #задает особый формат, в котором должно выводться сообщение о нарушении
               await channel.send(embed=embed) #отправляет сообщение в указанный выше канал в особом, также указанном выше, формате
               await message.author.send(f"Please stop using bad words!") #отправляет личное сообщение с требованием прекратить использовать запрещенные слова его автору
               return #останавливает функцию
      await bot_Mess.process_commands(message) #останавливает работу всех остальных
      #здесь заимствование кода прекращается

#следующая часть кода была во многом взята из следующего видео: https://www.youtube.com/watch?v=37kEluk_rls&ab_channel=clvrk
@bot_Mess.command()
@commands.has_permissions(administrator = True)
async def createCh(ctx, *channels): #создает функцию для добавления новых текстовых каналов
   '''Функция создания произвольного количества каналов на сервере. На вход принимается сама команда и названия новых каналов через пробел. Команда требует прав администратора.
   аргумент ctx функции - контекст
   аргумент *channels функции - перечень всех названий для новых каналов, записывается в список channels'''
   for channel in channels: #перебирает все названия для новых каналов среди введенных в сообщении
      await ctx.guild.create_text_channel(channel) #получает сервер, на который было отправлено сообщение, затем создает там текстовым каналом со взятым из списка в цикле названием
      await ctx.send(f'text channel {channel} has been created') #отправляет в канал, в который было отправлено сообщение, ответ о том, что канал с указанным названием был создан

@bot_Mess.command()
@commands.has_permissions(administrator = True)
async def deleteCh(ctx, *channels: discord.TextChannel): #создает функцию для удаления текстовых каналов
   '''Функция удаления произвольного количества каналов на сервере. На вход принимается сама команда и названия каналов, которые требуется удалить. Команда требует прав администратора.
   аргумент ctx функции - контекст
   аргумент *channels функции - перечень всех названий удаляемых каналов, записывается в список channels'''
   for channel in channels: #перебирает все названия удаляемых каналов среди введенных в сообщении
      await channel.delete() #удаляет на сервере канал по заданному названию
      await ctx.send(f'text channel {channel} has been deleted') #отправляет в канал, в который было отправлено сообщение, ответ о том, что канал с указанным названием был удален
#тут заимствование кода заканчивается

@bot_Mess.command(pass_context = True)
@commands.has_permissions(administrator = True)
async def kick(ctx, user: discord.Member): #создает функцию для исключения участников с сервера
   '''Функция исключения указанного участника сервера. На вход принимается сама команда и имя участника. Команда требует прав администратора.
   аргумант ctx функции - контекст
   аргумент user - имя пользователя, которого требуется исключить'''
   await ctx.channel.purge(limit = 1) #удаляет одно сообщение из канала, а именно то, которое и было с требованием исключить участника
   await ctx.send(f'{user.mention} was kicked from this server by {ctx.message.author.mention}') #отправляет в канал сообщение, что указанный пользователь был кикнут с сервера отправителем команды
   await user.send(f'You were kicked from server by {ctx.message.author.mention}') #отправляет исключенному пользователю личное сообщение о том, что он был исключен с сервера
   await user.kick() #удаляет указанного участника с сервера

@bot_Mess.command() # команда для бота
async def guess_game(ctx, type, userch):
    '''

    функция для игры с пользователем с тремя режимами
    при выборе режима:
    1 - пользователь испытывает возможность угадать число от 0 до 10
    2 - пользователь испытывает возможность угадать число от 0 до 100
    3 - пользователь испытывает возможность угадать число от 0 до 1000000
    ctx - контекст
    type - выбор режима от пользователя
    userch - число, выбранное пользователем
    '''
    author = ctx.message.author # указывает на автора команды
    try: # дальнейшие действия, если все аргументы указаны правильно
        winner = False # булевая переменная для проверки победил ли пользователь после цикла
        z = '' # строка в которую записывается новый ник после попытки
        if int(type) == 1: # если тип игры равен 1
            rannum = random.randint(0,10) # rannum - рандомное число от 0 до 10 включительно, с помощью команды randint из random
            if int(userch) == rannum: # если число пользователя совпало с рандомным числом
                winner = True # запись, что пользователь победил
                z = 'Обычный везунчик' # изменение конечного никнейма пользователя
            else: # если пользователь проиграл
                z = 'Лузер' # то никнейм меняется на другой
        elif int(type) == 2: # иначе если тип игры равен 2
            rannum = random.randint(0, 100)  # rannum - рандомное число от 0 до 100 включительно, с помощью команды randint из random
            if int(userch) == rannum: # если число пользователя совпало с рандомным числом
                winner = True # запись, что пользователь победил
                z = '1%' # изменение конечного никнейма пользователя
            else: # если пользователь проиграл
                z = 'Может в казино?' # то никнейм меняется на другой
        elif int(type) == 3: # иначе если тип игры равен 2
            rannum = random.randint(0, 1000000) # rannum - рандомное число от 0 до 1000000 включительно, с помощью команды randint из random
            if int(userch) == rannum: # если число пользователя совпало с рандомным числом
                winner = True  # запись, что пользователь победил
                z = 'БОГОПОДОБЕН' # изменение конечного никнейма пользователя
            else: # если пользователь проиграл
                z = 'Ожидает многого от жизни' # то никнейм меняется на другой
        else: #если указан иной тип игры
            await ctx.send(f'Ошибка') # выводим в канал сообщение об ошибке
            return # выходим из функции
    except: # при исключении
        await ctx.send(f'Ошибка') #пишем об ошибке
        return # выходим из функции
    await ctx.send('🎲 бот подкручивает шансы... 🎲') #если все успешно, то выводим сообщение от бота
    time.sleep(1) # задержка, чтобы было немного интриги
    if winner: # если пользователь победил
        await ctx.send('Поздравляю, но скольких попыток это тебе стоило?') # выводим сообщение для победного случая
    else: # иначе
        await ctx.send('Потом повезет... Пытайся больше :)') # выводим сообщение для случая проигрыша
        await ctx.send(f'Всего лишь надо было написать {rannum}') # выводим сообщение о загаданном ботом числе
    try: # попытка смены ника
        await ctx.send(f'Наслаждайся новым ником 😉') # вывод сообщения о смене ника
        await author.edit(nick = z) # меняем автору ник в соответствии с результатом попытки
    except: # если вызвано исключение
        await ctx.send(f'Слишком много чести для меня - менять ник админу 🙌') # сообщение о неудачной смене нике, если человек стоит выше по роли или он является админом

@bot_Mess.command() # команда для бота
async def rps(ctx):
    '''

    функция для игры бота с пользователем в камень - ножницы - бумагу
    при выборе режима:
    ctx - контекст
    '''
    author = ctx.message.author # указывает на автора команды
    rps_arr = ['Камень', 'Ножницы', 'Бумага'] # rps_arr - массив с возможными вариантами для игры
    botchoice = random.choice(rps_arr) # botchoice - выбор рандомного варианта игры для бота с помощью random.choice из массива rps_arr
    await ctx.send('Камень? Ножницы? Бумага? Выбирай внимательно.') # вывод сообщения пользователю для того, чтобы он выбрал тип игры
    user_choice = await bot_Mess.wait_for('message') # user_choice - выбор пользователя. bot_Mess.wait_for - указания к боту, чтобы он ждал сообщение с текстом
    t = user_choice.content # получение ответа пользователя в кач-ве строки
    t = t.lower() # команда, позволяющая пользователю вводить как с большой буквы, так и с маленькой
    if t == 'камень': # если ответ - это Камень
        if botchoice == 'Камень': # если выбор бота - Камень
            await ctx.send(f'🗿 == 🗿 \n {author.mention} думает аналогичну компьютеру 🧐') # выводим сообщение, что компьютер и пользователь выбрали одинаковое {author.mention} - тегаем пользователя
        elif botchoice == 'Ножницы': # иначе если выбор бота - Бумага
            await ctx.send(f'🗿 >> ✂ \n Поздравляю с победой {author.mention}') # выводим сообщение, что пользователь победил компьютер. {author.mention} - тегаем пользователя
        else: # иначе
            await ctx.send(f'🗿 << 📝 \n Хе-хе обкрутил камень {author.mention} 🦾 ') # выводим сообщение, что компьютер победил пользователя. {author.mention} - тегаем пользователя
        return # выходим из функции
    elif t == 'бумага': # иначе если ответ - это бумага
        if botchoice == 'Камень': # если выбор бота - Камень
            await ctx.send(f'📝 >> 🗿 \n {author.mention} обыграл бота. Поздравим!') # выводим сообщение, что пользователь победил компьютер. {author.mention} - тегаем пользователя
        elif botchoice == 'Ножницы':# иначе если выбор бота - Ножницы
            await ctx.send(f'📝 << ✂ \n Хах, {author.mention} думал победить компьютер 👹') # выводим сообщение, что компьютер победил пользователя. {author.mention} - тегаем пользователя
        else: # иначе
            await ctx.send(f'📝 == 📝 \n {author.mention} - это компьютер?? Не верю 😥') # выводим сообщение, что компьютер и пользователь выбрали одинаковое {author.mention} - тегаем пользователя
        return # выходим из функции
    elif t == 'ножницы': # иначе если ответ - это ножницы
        if botchoice == 'Камень': # если выбор бота - Камень
            await ctx.send(f'✂ << 🗿 \n Злой бот сломал ножницы {author.mention} 🤖') # выводим сообщение, что компьютер победил пользователя. {author.mention} - тегаем пользователя
        elif botchoice == 'Ножницы': # иначе если выбор бота - Ножницы
            await ctx.send(f'✂ == ✂ \n {author.mention} сыграл вничью со мной  🧠') # выводим сообщение, что компьютер и пользователь выбрали одинаковое {author.mention} - тегаем пользователя
        else: # иначе
            await ctx.send(f'✂ >> 📝 \n {author.mention} прочитал меня и переиграл 🥶') # выводим сообщение, что пользователь победил компьютер. {author.mention} - тегаем пользователя
        return # выходим из функции
    else: # иначе
        await ctx.send('Ошибка! Введите ваш выбор правильно.') # выводим сообщение об ошибке в выборе пользователя

@bot_Mess.command() # команда для бота
async def rusgame(ctx, opponent: discord.Member):
    '''

    функция для игры c человеком в русскую рулетку со сменой ника проигравшего
    при выборе режима:
    ctx - контекст
    discord.Member - класс, который помогает взаимодействовать с пользователями
    opponent - это тегнутый пользователь при вызове команды
    '''
    author = ctx.message.author # указывает на автора команды
    await ctx.send(f'{author.mention} предлагает сыграть {opponent.mention} в Русскую рулетку 😬🔫') # выводит в чат, что автор команды желает сыграть с тегнутым пользователем
    time.sleep(0.5) # задержка перед следующим действием
    await ctx.send(f'{opponent.mention}, введите любой символ, если согласны') # выводит в чат просьбу ответа от тегнутого пользователя

    def check(user): # проверка на тегнутого пользователя, совпадает ли сообщение от произвольного пользователя с тегнутым
        z = user.author.name + '#' + user.author.discriminator # достаем из того, кто написал сообщение, имя + дискорд - тег
        return str(z) == str(opponent) # выводим равен ли дискорд тег + имя, от пользователя, который написал сообщение, изначальному, с кем хотели сыграть
    try: # если сообщение отправляется
        user_choice = await bot_Mess.wait_for('message', timeout=5.0, check=check) # даем 5 секунд на отправку от пользователя
    except asyncio.TimeoutError: # если 5 секунд истекают, а тегнутый пользователь не ответил
        await ctx.send(f'{opponent.mention} не захотел испытывать свою жизнь или не успел принять приглашение 💔') # выводим, что пользователь не откликнулся

    else: # если все хорошо и пользователь откликнулся
        newnicknames = ['zxcghoul666', 'dead inside', 'thx for SBEU', 'le-le-le me die'] # создаем массив с никнеймами проигравшему
        nick = random.choice(newnicknames) # берем рандомный ник методом random.choice
        players = [author, opponent] # добавляем в массив author - автор сообщения, opponent - тегнутый пользователь
        whofirst = random.choice(players) # выбираем, кто будет стрелять первым :)
        whosecond = opponent # изначально вторым стреляет тегнутый пользователь
        if whofirst == author: # если выпало, что первым начинает автор
            await ctx.send(f'{author.mention} начинает испытание на смерть!') # выводим сообщение, что начинает автор
        else: #иначе
            await ctx.send(f'{opponent.mention} попытается выжить в первом ходу!') # выводим соообщение, что начинает тегнутый пользователь
            whosecond = author # тогда меняем переменную и получаем, что автор ходит второй

        baraban = [0] * 6 # создаем массив из шести нулей (пусть это барабан пистолета)
        baraban[random.randint(0,5)] = 1 # заменяем один элемент единицей - это будет пуля
        for i in range(len(baraban)): # идем от 0 до длины массива
            chance = int(100-int(1/(len(baraban) - i) * 100)) # подсчитываем шанс выживания на данном ходу
            if i == len(baraban) - 1: # если мы на последнем элементе массива
                await ctx.send(f'{whosecond.mention} завещает все своей собаке и идет на верную смерть') # выводим, что пользователь проиграл
                try: # пытаемся поменять пользователю ник
                    await whosecond.edit(nick=nick) # изменяем ник пользователя, который ходил вторым
                except: # если не получилось
                    await ctx.send(f'{whosecond.mention} оказывается не простой человек на этом сервере') # выводим причину не смены ника в чат
                return # выходим из функции
            elif i%2 == 0: # иначе, если сейчас ходит первый
                await ctx.send(f'{whofirst.mention} стреляет') # выводим сообщение, что первый игрок стреляет
                time.sleep(1) # создаем задержку для небольшой интриги
                if baraban[i] == 0: # если значение элемента в массиве равно 0
                    await ctx.send(f'{whofirst.mention} везёт! Он выживает с {chance}% шансом') # выводим сообщение, что пользователь выживает с определенным шансом
                if baraban[i] == 1: # если значение элемента в массиве равно 1
                    await ctx.send(f'{whofirst.mention} погибает от шальной пули😭') # выводим сообщение, что пользователь умирает
                    try:# пытаемся поменять пользователю ник
                        await whofirst.edit(nick=nick) # заслуженно меняем первому стрелявшему ник
                    except:# если не получилось
                        await ctx.send(f'{whofirst.mention} - он засланный казачок что ли!? Слишком много привилегий 🤬') # выводим причину не смены ника в чат
                    return # выходим из функции
            else: # иначе
                await ctx.send(f'{whosecond.mention} испытывает свою удачу') # выводим сообщение, что второй игрок стреляет
                time.sleep(1) # создаем задержку для небольшой интриги
                if baraban[i] == 0: # если значение элемента в массиве равно 0
                    await ctx.send(f'{whosecond.mention} везёт! Он выживает с {chance}% шансом') # выводим сообщение, что пользователь выживает с определенным шансом
                if baraban[i] == 1: # если значение элемента в массиве равно 1
                    await ctx.send(f'{whosecond.mention} получает СБЭУ👺') # выводим сообщение, что пользователь умирает
                    try:# пытаемся поменять пользователю ник
                        await whosecond.edit(nick=nick)  # меняем второму стрелявшему ник
                    except:# если не получилось
                        await ctx.send(f'{whosecond.mention} Да что с тобой не так...') # выводим причину не смены ника в чат
                    return # выходим из функции

@bot_Mess.event
async def on_ready():   # Вызываем асинхронную функцию по выводу включения бота.
    '''Данная функция работает пока включен бот.
    Данная функция выводит в консоль сообщение о том, что бот запущен.
    А так же как бот включается меняет его активность на ту которую пожелает пользователь.
    Часть кода взята с сайта https://ru.stackoverflow.com/questions/1144828/%D0%90%D0%B2%D1%82%D0%BE-%D0%B2%D1%8B%D0%B4%D0%B0%D1%87%D0%B0-%D1%80%D0%BE%D0%BB%D0%B5%D0%B9-%D0%BF%D1%80%D0%B8-%D0%B2%D1%85%D0%BE%D0%B4%D0%B5-%D0%BD%D0%B0-%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80
    Или https://clck.ru/ZPDP4'''
    print("Bot is ready")   # Выводит, что бот готов и запущен.
    await bot_Mess.change_presence(status=discord.Status.idle, activity=discord.Game("Python"))   # Тут у бота в дискорде пишется во, что он играет. Вместо Python можно написать все что угодно.

@bot_Mess.event
async def on_command_error(ctx, error):   # Запускает функцию если введена неправильная команда.
    '''Данная функция работает пока включен бот.
    Если кто-то напишет в чат "+" и далее неверную программу, то эта функция сообщит об ошибке у пользователя.
    authour - переменная, которая хранит в себе id пользователя, которому нужно выдать роль.
    аргумент ctx функции отвечает за контекст.
    аргумент error функции отвечает за ошибку.'''
    author = ctx.message.author   # Получает id автора сообщения.
    await ctx.send(f'{author.name}, sorry, but this command does not exist.')   # Ввыводит сообщение если команда неправильная.
    print(f'find {error}')   # Выводит в консоль сообщение об ошибке.

@bot_Mess.command()
async def choose(ctx, *words):   # Запускает функцию которая запоминает все значения введенные через пробел после +(команды)
    '''Данной функцией могут воспользоваться все пользователи.
    Для запуска функции нажно написать в чат ДС сервера "+choose ...". Где ... это значение из которых нужно выбрать только одно.
    i - рандомный индекс значения из массива.
    *words - аргумент, который записывает в переменную words все значение (слова, числа и т.д.) из которых мы будем в дальнейшем выбирать.
    аргумент ctx функции отвечает за контекст.'''
    i = randint(0,len(words)-1)   # Получает рандомное значение id массива из введенных значений.
    await ctx.send(f'How about this - {words[i]}? From this List{words}')   # Выводит рандомно-выбранное значение из введенного списака и сам список.
    await ctx.message.delete()   # Удаляет ваше сообщение чтобы не захламлять чат.

@bot_Mess.command()
async def roll(ctx):   # Запускает функцию по выбору рандомного числа.
    '''Данной функцией могут воспользоваться все пользователи.
    Для запуска функции нажно написать в чат ДС сервера "+roll".
    Бот выведит в чат сообщение с рандомным значение от 1 до 100.
    authour - переменная, которая хранит в себе id пользователя, которому нужно выдать роль.
    Roll - переменная, которая хранит в себе рандомное число от 1 до 100.
    аргумент ctx функции отвечает за контекст.'''
    author = ctx.message.author   # Получает id автора сообщения.
    Roll = randint(1,100)   # Выбирает рандомное число.
    await ctx.send(f'{author.name} Roll: {Roll}')   # Выводит в чат сообщение с рандомным выбранным значением.
    await ctx.message.delete()   # Удаляет ваше сообщение чтобы не захламлять чат.

@bot_Mess.command()   # Задает значение функции по команде. Будет выполнятся только если ввести префикс с названием функции.
@commands.has_permissions(administrator = True)
async def del_role(ctx):   # Вызывает асинхронную функцию по удалении роли.
    '''Данной функцией могут воспользоваться только админы ДС сервера.
    Для запуска функции нажно написать в чат ДС сервера "+del_role Role". Где Role - это роль пользователя которую нужно удалить из txt файла (списка)."
    Данная функция удаляет роль из txt файла, из списка ролей.
    ROLES - массив с ролями.
    Roles - переменная, хранящая открытый файл с ролями.
    word - переменнаяч, хранящая одно слово из файла txt (списка ролей).
    аргумент ctx функции отвечает за контекст.'''
    ROLES = []   # Создает массив
    try:
        Roles = open('roles.txt', 'r')   # Открывает файл для чтения.
    except FileNotFoundError:   # Если не выполнилось открытие файла.
        pass
    gg = (ctx.message.content).split(' ')   # Записывыет в переменную значение из вашего сообщения.
    for word in Roles:   # Выписывает значения из открытого файла.
        if word.strip() != gg[1]:   # Проверяет на схожесть значения которое мы должны удвлить.
            ROLES.append(word.strip())   # Добавляет обратно все наши значение уже без того, которые мы хотели удалить.
    Roles.close()   # Закрывает файл.

    Roles = open('roles.txt', 'w')   # Открывает чистый файл для редактирования.
    if ROLES != []:   # Проверяет чистый ли массив.
        Roles.write(ROLES[0])   # Записывает первое значени обратно в файл.
    if len(ROLES) > 1:   # Проверяет длину нашего массива.
        for i in range(1,len(ROLES)):   # Берем по значентю из массива кроме 0.
            Roles.write('\n' + ROLES[i])   # Записывает все наши значения обратно в файл.
    await ctx.message.delete()   # Удаляет ваше сообщение чтобы не захламлять чат.

    return ('Del')  # Выводит конец функции в консоль.

@bot_Mess.command()
async def create_role(ctx):   # Вызывает асинхронную функцию по создании роли.
    '''Данной функцией могут воспользоваться все пользователи ДС сервера.
    Для запуска функции нажно написать в чат ДС сервера "+create_role Role Color". Где Role - это роль которую нужно создать.
    Данная функция создает роль. Если пользователь хочет создать и добавить себе роль, то он может написать название роли и её цвет.
    Так же функция сразу добавляет эту роль в txt файл (список ролей).
    ROLES - массив с ролями.
    Roles - переменная, хранящая открытый файл с ролями.
    word - переменнаяч, хранящая одно слово из файла txt (списка ролей).
    role - переменная, которая хранит значение нашей роли.
    guild - переменная, в которой хранится id discord сервера, чтобы боту знать, где создать роль.
    color - переменная, которая хранит в себе значение цвета роли, которую мы хотим добавить.
    authour - переменная, которая хранит в себе id пользователя, которому нужно выдать роль.
    аргумент ctx функции отвечает за контекст'''
    try:   # Будет выполнятся если не None.
        gg = (ctx.message.content).split()   # В переменную записываает всё наше сообщение разделяя по пробелам. Получает на выходе массив.
        guild = ctx.guild   # Записывает в переменную guild id нашего discord сервера.
        color = int((gg[2][2:]), 16)   # Находит значение вашего цвета в шестнадцатеричном представление (0xffffff).
        role = await guild.create_role(name=str(gg[1]), permissions=discord.Permissions(0), colour=discord.Colour(color))   # Задает значение нашей роли и создает её. Название. Позицию в иерархии ролей в дискорде.
        authour = ctx.message.author   # Получаем id автора сообщения.
        await authour.add_roles(role)   # Добавляем нашу роль себе.

        try:
            roles = open('roles.txt', 'a')   # Открывает файл с ролями для редаккторования.
        except FileNotFoundError:   # Если файл не смог открыться.
            roles = open('roles.txt', 'w')   # Отккрывает файл как пустой.
        if os.stat("roles.txt").st_size > 0:   # Получает значения размера файла.
            print(str(gg[1]))
            roles.write('\n' + str(gg[1]))  # добавляет их с новой строки в файл
        else:
            print(str(gg[1]))
            roles.write(str(gg[1]))

        await ctx.message.delete()   # Удаляет ваше сообщение чтобы не захламлять чат.
    except:
        print("Something went wrong")   # Выводит в консоль сообщение об ошибке.

@bot_Mess.command()
async def give_role(ctx):   # Запускает функцию по выдаче ролей.
    '''Данной функцией могут воспользоваться все пользователи ДС сервера.
    Для запуска функции нажно написать в чат ДС сервера "+give_role Role". Где Role - это роль которую нужно добавить.
    Данная функция добавляет роль. Если пользователь хочет добавить себе роль, то он может добавить роль из списка ролей.
    ROLES - массив с ролями.
    Roles - переменная, хранящая открытый файл с ролями.
    word - переменнаяч, хранящая одно слово из файла txt (списка ролей).
    role - переменная, которая хранит значение нашей роли.
    аргумент ctx функции отвечает за контекст'''
    ROLES = []   # Открывает массив.
    try:
        Roles = open('roles.txt', 'r')   # Открывает файл для чтения.
    except FileNotFoundError:
        Roles = open('roles.txt', 'w')   # Открывает пустой файл.
        Roles.close()   # Закрывает файл
        Roles = open('roles.txt', 'r')   # Открывает файл для чтения.
    for word in Roles:   # Выписывает все слова из файла.
        ROLES.append(word.strip())   # Добавляет все слова в массив ролей.

    for i in range(len(ROLES)):   # Находит значения i для длины массива ролей.
        if ROLES[i] in ctx.message.content:   # Проверяет какую роль мы хотим добавить.
                member = ctx.message.author   # Получает id автора сообщения.
                role = discord.utils.get(ctx.message.guild.roles, name= ROLES[i])   # Добавляет в значение role вашу роль, которую вы хотите добавить.
                await member.add_roles(role)   # Добавляет выбранную вами роль.
                await ctx.message.delete()   # Удаляет ваше сообщение чтобы не захламлять чат.

@bot_Mess.command()
async def remove_role(ctx):
        '''Данной функцией могут воспользоваться все пользователи ДС сервера.
        Для запуска функции нажно написать в чат ДС сервера "+remove_role Role". Где Role - это роль которую нужно убрать.
        Данная функция убирет роль. Если у пользователя есть роль которую он когда-то добавил, то он может её убрать.
        Данная роль должна находится в txt файле ролей.
        ROLES - массив с ролями.
        Roles - переменная, хранящая открытый файл с ролями.
        word - переменнаяч, хранящая одно слово из файла txt (списка ролей).
        role - переменная, которая хранит значение нашей роли.
        аргумент ctx функции отвечает за контекст'''
        ROLES = []   # Открывает массив.
        try:
            Roles = open('roles.txt', 'r')   # Открывает файл для чтения.
        except FileNotFoundError:
            Roles = open('roles.txt', 'w')   # Открывает пустой файл.
            Roles.close()   # Закрывает файл
            Roles = open('roles.txt', 'r')   # Открывает файл для чтения.
        for word in Roles:   # Выписывает все слова из файла.
            ROLES.append(word.strip())   # Добавляет все слова в массив ролей.

        for i in range(len(ROLES)):   # Находит значения i для длины массива ролей.
            if ROLES[i] in ctx.message.content:   # Проверяет какую роль мы хотим добавить.
                member = ctx.message.author   # Получает id автора сообщения.
                role = discord.utils.get(ctx.message.guild.roles, name= ROLES[i])   # Добавляет в значение role вашу роль, которую вы хотите добавить.
                await member.remove_roles(role)    # Убирает выбранную вами роль.
                await ctx.message.delete()   # Удаляет ваше сообщение чтобы не захламлять чат.

@bot_Mess.command()
@commands.has_permissions(administrator = True)
async def mute(ctx, user: discord.Member):
    '''Данной функцией могут воспользоваться только админы ДС сервера.
    Для запуска функции нажно написать в чат ДС сервера "+mute User". Где User - это пользователь которого нужно забанить."
    Данная функция выдает роль [Mute]. А так же убирает все роли пользователя на кого накладываетс.
    Данную роль можно самому настроить. И как в итоге человек имеет одну роль. В которой прописанно, что пользователю запрещается: говорить, писать в текстовые каналы и т.д.
    А так жепишет в чат пользователя которого забанили.
    banned_role - переменная, в которую записывается роль означающая бон.
    аргумент ctx функции отвечает за контекст.
    аргумент user отвечает за пользователя.
    Часть кода взята с сайта https://question-it.com/questions/3190550/udalenie-vseh-rolej-polzovatelja-discordpy'''

    await asyncio.sleep(1)   # Выполняет функции с задержкой в одну секунду.
    banned_role = discord.utils.get(user.guild.roles, name="[Mute]")   # Выписывает роль которая означает, что пользователь забанен.
    await user.edit(roles=[]) # Удаляет все существующие роли у человека.
    await user.add_roles(banned_role) # Выдает роль бана.
    await ctx.message.delete()   # Удаляет ваше сообщение чтобы не захламлять чат.
    await ctx.send(f'yууу {user.mention}, плохой')   # Выводит в чат сообщение о том какой забаненный человеу плохой.


TOKEN = open('token.txt', 'r').read()
bot_Mess.run(TOKEN)
